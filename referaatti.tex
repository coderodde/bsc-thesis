\documentclass[12pt]{article}

\usepackage[finnish]{babel}
\usepackage[utf8x]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{graphicx}
\usepackage[ruled,linesnumbered,noend]{algorithm2e}
\usepackage{empheq}
\usepackage{float}

\title{Polunhakualgoritmit ja -järjestelmät -- referaatti}
\author{Rodion ``rodde'' Efremov}

\begin{document}
 \maketitle
\noindent Lyhimpien polkujen haku painotetuissa tai painottamattomissa verkoissa on perustavanlaatuinen ongelma, joka ei ole tärkeä vain itsessään, vaan sillä on sovelluksia joukossa algoritmeja, joissa lyhimmän polun haku on tarvittava alioperaatio; esim. Edmonds-Karp algoritmi hakee aina lyhimmät painottamattomat polut verkossa (engl. \textit{residual graph}) ratkaistaakseen maksimivuo-ongelman (engl. \textit{maximum flow problem}). Tietenkin, varsinainen sovellus on reitin optimointi erilaisten mittojen mukaan: toisinaan halutaan päästää pisteestaä $A$ pisteeseen $B$ mahdollisimman pienessä ajassa (henkilöauto), toisinaan mahdollisimman ekologisesti (polkupyörä), jne.

Vuonna 1959 Edsger W. Dijkstra esitti polynomisessa ajassa toimivan algoritmin \cite{Dijkstra59}, joka, saatuaan lähtösolmun $s$, laskee lyhimpien polkujen puun solmusta $s$ kaikkiin muihin saavutettaviin solmuihin painotetuissa verkoissa. Kuten monet muut, Dijkstran algoritmi vaatii prioriteettijonorakenteen (engl. \textit{priority queue}, \textit{heap}), mikä on vain yksi optimointiulottuvuus. Helpoin, tehokkaaksi kutsuttu prioriteettijonorakenne on binäärikeko, joka toteuttaa kaikki sisältöä muokkaavat operaatiot ajassa $O(\log n)$, jolloin Dijkstran algoritmin aikavaativuus on $O((m + n) \log n)$. Parannus edelliseen on ilmestynyt vuonna 1987 Fibonacci-keon myötä, jonka minimin poisto käy tasoitetussa (engl. \textit{amortized}) ajassa $O(\log n)$, ja muut sisältöä muokkaavat operaatiot tasoitetussa tai eksaktissa vakioajassa, jolloin paremmaksi Dijkstran algoritmin aikavaativuudeksi on tullut $O(m + n\log n)$. 

Mitä tulee muihin nopeutustekniikoihin, Hart et al. esittivät vuonna 1968 $A\ast$-polun\-hakualgoritmin \cite{Hart68}, joka ei lajittele solmut pelkän $g$-arvon mukaan (solmun $u$ $g$-arvo on toistaiseksi paras etäisyys lähtösolmusta $u$:hun), vaan käyttää $f$-arvoa, jolle $f = g + h$, missä $h$ on solmun optimistinen (eli aliarvioiva) etäisyys maalisolmuun. Intuitio tämän järjestelyn takana on se, että $A\ast$ ``tietää'' mihin suuntaan kannattaa lähteä päästääkseen maalisolmuun, ainakin paremmin kuin Dijkstran algoritmi, joka etenee ``kaikkiin suuntiin''. Toisaalta, $A\ast$ sai varteenotettavan kilpailijan, nimittäin \textit{kaksisuuntainen} Dijkstran algoritmi kasvattaa kaksi lyhimpien polkujen puuta kunnes kaksi ``kohtaavat keskellä''. Jos abstrahoidaan prioriteettijonon operaatioiden aikavaativuudet pois, alkuperäinen Dijkstran algoritmi tekee $\sum_{i = 0}^N d^i$ verran työtä, kun kaksisuuntainen versio tekee vain noin $2\sum_{i=0}^{\lceil N / 2 \rceil}d^i$, missä $d$ on verkon solmujen keskiarvoinen aste ja $N$ on lyhimmän polun solmujen määrä. (Ylläoleva analyysi pätee kaksisuuntaiseen leveyssuuntaiseen hakuun sellaisenaan.) $A\ast$:n kaksisuuntaistaminen ei kuitenkaan ole aina kannattavaa, sillä kaksi hakua voivat ohittaa esteen ``eri puolilta'', jolloin tehdään enemmän työtä kuin tavallinen $A\ast$ olisi tehnyt.

Mikäli kysytään, mikä on tehokkain tapa laskea lyhin polku solmujen $s, v$ välillä, niin todennäköisesti päädytään aikaan $\Theta(N)$, missä $N$ on lyhimmän $s, v$-polun solmujen määrä. Tällainen tehokkuus kuitenkin vaatii ns. ``edeltäjämatriisin' (engl. \textit{predecessor matrix}), jonka voi laskea ajaamalla kaikkien parien algoritmin (engl. \textit{all-pairs shortest paths}). Niistä kaksi tunnetuinta ja helpommin toteuttavaa ovat \textsc{Floyd-Warshall}- ja Johnsonin algoritmit, jotka käyvät ajassa $O(V^3)$ ja $O(V^2 \log V + VE)$ vastaavasti, jolloin on selvää, ettei niitäkään pysty ottaa käyttöön, kun verkkona on esimerkiksi kokonaisen valtion tieverkosto, jossa solmuja on reilusti yli 10000. Tähän on kuitenkin tullut parannus: Möhring et al. esittivät ajatuksen osittaa \textit{harvan} verkon solmujoukko $V$ osioihin $V_1, V_2, \dots, V_k$, joille $\cup_{i = 1}^k V_i = V$ ja $V_i \cap V_j = \varnothing$ jokaisella $i \neq j$, minkä jälkeen jokaiselle verkon kaarelle $a \in E$ liitetään bittivektori $(b_1, b_2, \dots, b_k)$, jossa bitti $b_i$ on päällä, jos $a$ on lyhyellä polulla johonkin osion $i$ solmuun \cite{Mohring07}. Käytännössä $k$:n osion ositus toteutetaan funktiolla $r \colon V \to \{1, 2, \dots, k\}$; lisäksi, määritellään \textit{rajasolmun} käsite: osion $i$ rajasolmujen joukko on $B_i = \{v \in V_i \colon \exists(u, v) \in E \text{ siten että } r(v) \neq r(u) \}$. Jo tässä vaiheessa on tärkeää huomata tekniikan vaativan esiprosessointia saadaakseen bittivektorit (engl. \textit{arc-flags}) asetettua oikein. Siis olkoon $s(b)$ joukko solmuja $u$ siten että $b$ on rajasolmu ja jokaisella $u \in s(b)$ on voimassa $(u, b) \in E$ ja $r(u) \neq r(b)$. Nyt jokaisen rajasolmun $b$ jokaisesta solmusta $u \in s(b)$ on laskettava ``takaperin'' lyhimpien polkujen puu, jonka jokaiseen kaareen $a$ liittyvään bittivektoriin $f(a)$ laitetaan $r(b)$:s bitti päälle. (Varsinainen polun haku solmuun $t$ ko. järjestelmässä karsii kaikki kaaret $a$ pois, joille asianmukainen bitti ei ole päällä; ainakin niin pitkään kunnes pääsee samaan osioon maalisolmun kanssa.) Kuten yllä kävi ilmi, \textit{Dijkstra with arc-flags} -järjestelmä uhraa aikaa esiprosessointiin nopeuttaakseen hakuoperaatioita. Tekniikka voidaan nähdä tasapainoilevan tavallisen Dijkstran algoritmin ($V_1 = V$) ja kaikki-parit --algoritmin (jokainen ositus sisältää vain yhden solmun) välillä, ja on varteenotettava algoritmi, sillä on raportoitu jopa 500-kertainen nopeutus suhteessa Dijkstran algoritmiin. 

Osittaessa verkkoja Möhring et al. kokeilivat neljä tapaa. Niistä helpointen toteuttava on jakaa koko verkko $w$ sarakkeeseen ja $h$ riviin, jolloin kaikki osiot ovat geometrisesti yhtä suuria. Tämä ei kuitenkin ole vailla ongelmia; esim. 50 neliökilometrin suorakulmio pääkaupungin kohdalla sisältäisi oleellisesti enemmän solmuja ja kaareja kuin jokin alue Kainuun maakunnassa. Hieman parempi tapa osioida verkko on käyttää ``nelipuu'' (engl. \textit{quadtree}), joka jokaisella tasollaan jakaa kunkin suorakulmion neljään yhtä isoon pienempään suorakulmioon seuraavalle tasolle pysäyttäen jaon niiden suorakulmioiden kohdalla, jossa on enintään $n$ solmua ($n$ on rakenteelle annettava parametri). Toisin kuin ensimmäinen tapa, nelipuut alkaavat ottaa solmujen jakauman huomioon, vaikkakin ei niin monipuolisesti kuin $kd$-puu (engl. \textit{$kd$-tree}), joka lajittele kaikki solmut esimerkiksi $x$-koordinaattien perusteella, valitsee listasta mediaanin, jonka $x$-koordinaatti on $x_{mid}$, ja jakaa solmut joukkoihin $V_? = \{ x \colon x \, ? \, x_{mid} \}$, missä $? \in \{ \leq, >\}$, minkä jälkeen jaetaan molemmat samalla tavalla, mutta $y$-koordinaattien perusteella ja niin vaihtelevasti edelleen, kunnes jokaisessa osiossa on enintään $n$ solmua ($n$ annetaan parametrina). Neljäs ja viimeinen tarkasteltu ositustapa perustuu Karypis ja Kumarin tulokseen \cite{Karypis98}: METIS, joka toimii siten, että se yhdistää paremmin yhdistetyt solmuryppäät yhdeksi solmuksi, ja jatkaen näin tuottaa toista pienemmät verkot $G_0 = G, G_1, \dots, G_m$ kunnes $G_m$ on niin pieni, että sille voi laskea tehokkaasti ositus, joka minimoi niiden kaarien määrä, jotka yhdistävät kaksi erilaista osiota. Kun $G_m$ on valmis, edetään päinvastaiseen suuntaan ja laajennetaan väliverkot $G_{m - 1}, \dots, G_1$ saadakseen alkuperäisen verkon $G = G_0$. Siis käyttämällä METIS-osituksen saadaan vähiten rajasolmuja suhteessa muihin ositustekniikoihin, mikä parantaa esiprosessointiaikoja, ja toisin kuin muut, METIS ei edes tarvitse kunkin solmun koordinaatit. Lisäksi, mainittakoon, että olipa ositusalgoritmi mikä tahansa, eri osioiden käsittely voidaan suorittaa rinnakkain, sillä niiden välillä ei ole riippuvuuksia.

Vielä yksi nopeutustekniikka on tietenkin rinnakkaistaminen, ja \\ $\Delta$-stepping on juuri sitä optimointiulottuvuutta silmälläpitävä tekniikka \cite{Meyer98}. Epämuo\-dollisesti, $\Delta$-stepping algoritmi jakaa solmut koreihin (engl. \textit{bucket}), joista kukin sisältää ne solmut $u$, joiden toistaiseksi olevat $g$-arvot ovat välillä $[i\Delta, (i +1)\Delta)$, jolloin siis eri säikkeet käsittelevät eri koreissa olevia solmuja. Meyer et al. raportoivat peräkkäisen $\Delta$-stepping algoritmin olevan noin $3.1$ kertaa nopeampi kuin ``optimoitu'' alkuperäinen Dijkstran algoritmi, ja 16 suorittimen koneella paralleeli $\Delta$-stepping oli noin $9.2$ kertaa nopeampi verrattuna peräkkäiseen versioonsa. Tässä voi huomauttaa kuitenkin, että rinnakkaisten algoritminen kohdalla ei ole mahdollista saadaa mielivaltaisen suuria nopeutuksia jo Amdahlin lain nojalla.
\bibliographystyle{plain}
\bibliography{refs}

\end{document}